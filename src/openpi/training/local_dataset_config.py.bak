"""本地Bridge数据集配置，用于从本地加载Bridge格式数据。"""

import dataclasses
import logging
import pathlib
import sys
from typing import Any, Dict, Optional, Sequence

import etils.epath as epath
import torch
from typing_extensions import override

import openpi.models.model as _model
import openpi.shared.normalize as _normalize
import openpi.transforms as _transforms
from openpi.training.config import DataConfig, DataConfigFactory, ModelTransformFactory

# 导入原始的数据加载器
# sys.path.append('..')  # 确保可以导入外部模块
# from extern.bridge_lerobot_pipeline import make_dataloader, BridgeLeRobotIterableDataset


import sys
import os

# 添加调试信息，检查当前目录和sys.path
current_dir = os.path.abspath(os.path.dirname(__file__))
print(f"当前目录: {current_dir}")
print(f"父目录: {os.path.abspath(os.path.join(current_dir, '..', '..', '..',))}")

# 打印sys.path中的所有路径
print("当前Python搜索路径:")
for path in sys.path:
    print(f"  - {path}")

# 使用更明确的相对路径
extern_path = os.path.abspath(os.path.join(current_dir, '..', '..', '..', 'extern'))
print(f"尝试添加extern路径: {extern_path}")
print(f"extern目录存在: {os.path.exists(extern_path)}")

# 检查bridge_lerobot_pipeline.py是否存在
bridge_file = os.path.join(extern_path, 'bridge_lerobot_pipeline.py')
print(f"bridge_lerobot_pipeline.py存在: {os.path.exists(bridge_file)}")

# 添加extern路径到sys.path
sys.path.append(extern_path)

# 再次打印sys.path以确认路径已添加
print("添加extern后的Python搜索路径:")
print(f"  - {sys.path[-1]}")

# 现在尝试导入
try:
    from bridge_lerobot_pipeline import make_dataloader, BridgeLeRobotIterableDataset
    print("成功导入bridge_lerobot_pipeline模块!")
except ImportError as e:
    print(f"导入失败: {e}")
    
    # 尝试直接使用完整路径导入
    try:
        import importlib.util
        spec = importlib.util.spec_from_file_location("bridge_lerobot_pipeline", bridge_file)
        bridge_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(bridge_module)
        print("通过直接指定文件路径成功导入!")
        # 如果成功，可以这样使用模块
        make_dataloader = bridge_module.make_dataloader
        BridgeLeRobotIterableDataset = bridge_module.BridgeLeRobotIterableDataset
    except Exception as e2:
        print(f"使用直接路径导入也失败了: {e2}")




import abc
from collections.abc import Sequence
import dataclasses
import difflib
import logging
import pathlib
from typing import Any, Protocol, TypeAlias

import etils.epath as epath
import flax.nnx as nnx
from typing_extensions import override
import tyro
import openpi.models.model as _model
import openpi.models.pi0 as pi0
import openpi.models.pi0_fast as pi0_fast
import openpi.models.tokenizer as _tokenizer
import openpi.policies.aloha_policy as aloha_policy
import openpi.policies.droid_policy as droid_policy
import openpi.policies.libero_policy as libero_policy
import openpi.shared.download as _download
import openpi.shared.normalize as _normalize
import openpi.training.optimizer as _optimizer
import openpi.training.weight_loaders as weight_loaders
import openpi.transforms as _transforms

# 首先需要在文件顶部导入Pi0FrankaConfig
import openpi.models.pi0_franka as pi0_franka

ModelType: TypeAlias = _model.ModelType
# Work around a tyro issue with using nnx.filterlib.Filter directly.
Filter: TypeAlias = nnx.filterlib.Filter



logger = logging.getLogger("openpi")



@dataclasses.dataclass(frozen=True)
class AssetsConfig:
    """Determines the location of assets (e.g., norm stats) that will be used to set up the data pipeline.

    These assets will be replicated inside the checkpoint under the `assets/asset_id` directory.

    This can be used to load assets from a different checkpoint (e.g., base model checkpoint) or some other
    centralized location. For example, to load the norm stats for the Trossen robot from the base model checkpoint
    during fine-tuning, use:

    ```
    AssetsConfig(
        assets_dir="s3://openpi-assets/checkpoints/pi0_base/assets",
        asset_id="trossen",
    )
    ```
    """

    # Assets directory. If not provided, the config assets_dirs will be used. This is useful to load assets from
    # a different checkpoint (e.g., base model checkpoint) or some other centralized location.
    assets_dir: str | None = None

    # Asset id. If not provided, the repo id will be used. This allows users to reference assets that describe
    # different robot platforms.
    asset_id: str | None = None


@dataclasses.dataclass(frozen=True)
class DataConfig:
    # LeRobot repo id. If None, fake data will be created.
    repo_id: str | None = None
    # Directory within the assets directory containing the data assets.
    asset_id: str | None = None
    # Contains precomputed normalization stats. If None, normalization will not be performed.
    norm_stats: dict[str, _transforms.NormStats] | None = None

    # Used to adopt the inputs from a dataset specific format to a common format
    # which is expected by the data transforms.
    repack_transforms: _transforms.Group = dataclasses.field(default_factory=_transforms.Group)
    # Data transforms, typically include robot specific transformations. Will be applied
    # before the data is normalized. See `model.Observation` and `model.Actions` to learn about the
    # normalized data.
    data_transforms: _transforms.Group = dataclasses.field(default_factory=_transforms.Group)
    # Model specific transforms. Will be applied after the data is normalized.
    model_transforms: _transforms.Group = dataclasses.field(default_factory=_transforms.Group)
    # If true, will use quantile normalization. Otherwise, normal z-score normalization will be used.
    use_quantile_norm: bool = False

    # Names of keys that will be used by the data loader to generate the action sequence. The length of the
    # sequence is defined by the `action_horizon` field in the model config. This should be adjusted if your
    # LeRobot dataset is using different keys to represent the action.
    action_sequence_keys: Sequence[str] = ("actions",)

    # If true, will use the LeRobot dataset task to define the prompt.
    prompt_from_task: bool = False


class GroupFactory(Protocol):
    def __call__(self, model_config: _model.BaseModelConfig) -> _transforms.Group:
        """Create a group."""


@dataclasses.dataclass(frozen=True)
class ModelTransformFactory(GroupFactory):
    """Creates model transforms for standard pi0 models."""

    # If provided, will determine the default prompt that be used by the model.
    default_prompt: str | None = None

    def __call__(self, model_config: _model.BaseModelConfig) -> _transforms.Group:
        match model_config.model_type:
            case _model.ModelType.PI0:
                return _transforms.Group(
                    inputs=[
                        _transforms.InjectDefaultPrompt(self.default_prompt),
                        _transforms.ResizeImages(224, 224),
                        _transforms.TokenizePrompt(
                            _tokenizer.PaligemmaTokenizer(model_config.max_token_len),
                        ),
                    ],
                )
            case _model.ModelType.PI0_FAST:
                return _transforms.Group(
                    inputs=[
                        _transforms.InjectDefaultPrompt(self.default_prompt),
                        _transforms.ResizeImages(224, 224),
                        _transforms.TokenizeFASTInputs(
                            _tokenizer.FASTTokenizer(model_config.max_token_len),
                        ),
                    ],
                    outputs=[
                        _transforms.ExtractFASTActions(
                            _tokenizer.FASTTokenizer(model_config.max_token_len),
                            action_horizon=model_config.action_horizon,
                            action_dim=model_config.action_dim,
                        )
                    ],
                )


@dataclasses.dataclass(frozen=True)
class DataConfigFactory(abc.ABC):
    # The LeRobot repo id.
    repo_id: str = tyro.MISSING
    # Determines how the assets will be loaded.
    assets: AssetsConfig = dataclasses.field(default_factory=AssetsConfig)
    # Base config that will be updated by the factory.
    base_config: tyro.conf.Suppress[DataConfig | None] = None

    @abc.abstractmethod
    def create(self, assets_dirs: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        """Create a data config."""

    def create_base_config(self, assets_dirs: pathlib.Path) -> DataConfig:
        repo_id = self.repo_id if self.repo_id is not tyro.MISSING else None
        asset_id = self.assets.asset_id or repo_id
        return dataclasses.replace(
            self.base_config or DataConfig(),
            repo_id=repo_id,
            asset_id=asset_id,
            norm_stats=self._load_norm_stats(epath.Path(self.assets.assets_dir or assets_dirs), asset_id),
        )

    def _load_norm_stats(self, assets_dir: epath.Path, asset_id: str | None) -> dict[str, _transforms.NormStats] | None:
        if asset_id is None:
            return None
        try:
            data_assets_dir = str(assets_dir / asset_id)
            norm_stats = _normalize.load(_download.maybe_download(data_assets_dir))
            logging.info(f"Loaded norm stats from {data_assets_dir}")
            return norm_stats
        except FileNotFoundError:
            logging.info(f"Norm stats not found in {data_assets_dir}, skipping.")
        return None


@dataclasses.dataclass(frozen=True)
class FakeDataConfig(DataConfigFactory):
    repo_id: str = "fake"

    @override
    def create(self, assets_dirs: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        return DataConfig(repo_id=self.repo_id)


@dataclasses.dataclass(frozen=True)
class SimpleDataConfig(DataConfigFactory):
    # Factory for the data transforms.
    data_transforms: tyro.conf.Suppress[GroupFactory] = dataclasses.field(default_factory=GroupFactory)
    # Factory for the model transforms.
    model_transforms: tyro.conf.Suppress[GroupFactory] = dataclasses.field(default_factory=ModelTransformFactory)

    @override
    def create(self, assets_dirs: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        return dataclasses.replace(
            self.create_base_config(assets_dirs),
            data_transforms=self.data_transforms(model_config),
            model_transforms=self.model_transforms(model_config),
            use_quantile_norm=model_config.model_type == ModelType.PI0_FAST,
        )


@dataclasses.dataclass(frozen=True)
class LeRobotAlohaDataConfig(DataConfigFactory):
    # If true, will convert joint dimensions to deltas with respect to the current state before passing to the model.
    # Gripper dimensions will remain in absolute values.
    use_delta_joint_actions: bool = True
    # If provided, will be injected into the input data if the "prompt" key is not present.
    default_prompt: str | None = None
    # If true, this will convert the joint and gripper values from the standard Aloha space to
    # the space used by the pi internal runtime which was used to train the base model. People who
    # use standard Aloha data should set this to true.
    adapt_to_pi: bool = True

    # Repack transforms.
    repack_transforms: tyro.conf.Suppress[_transforms.Group] = dataclasses.field(
        default=_transforms.Group(
            inputs=[
                _transforms.RepackTransform(
                    {
                        "images": {"cam_high": "observation.images.top"},
                        "state": "observation.state",
                        "actions": "action",
                    }
                )
            ]
        )
    )
    # Action keys that will be used to read the action sequence from the dataset.
    action_sequence_keys: Sequence[str] = ("action",)

    @override
    def create(self, assets_dirs: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        data_transforms = _transforms.Group(
            inputs=[aloha_policy.AlohaInputs(action_dim=model_config.action_dim, adapt_to_pi=self.adapt_to_pi)],
            outputs=[aloha_policy.AlohaOutputs(adapt_to_pi=self.adapt_to_pi)],
        )
        if self.use_delta_joint_actions:
            delta_action_mask = _transforms.make_bool_mask(6, -1, 6, -1)
            data_transforms = data_transforms.push(
                inputs=[_transforms.DeltaActions(delta_action_mask)],
                outputs=[_transforms.AbsoluteActions(delta_action_mask)],
            )

        model_transforms = ModelTransformFactory(default_prompt=self.default_prompt)(model_config)

        return dataclasses.replace(
            self.create_base_config(assets_dirs),
            repack_transforms=self.repack_transforms,
            data_transforms=data_transforms,
            model_transforms=model_transforms,
            action_sequence_keys=self.action_sequence_keys,
        )


@dataclasses.dataclass(frozen=True)
class LeRobotLiberoDataConfig(DataConfigFactory):
    """
    This config is used to configure transforms that are applied at various parts of the data pipeline.
    For your own dataset, you can copy this class and modify the transforms to match your dataset based on the
    comments below.
    """

    @override
    def create(self, assets_dirs: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        # The repack transform is *only* applied to the data coming from the dataset,
        # and *not* during inference. We can use it to make inputs from the dataset look
        # as close as possible to those coming from the inference environment (e.g. match the keys).
        # Below, we match the keys in the dataset (which we defined in the data conversion script) to
        # the keys we use in our inference pipeline (defined in the inference script for libero).
        # For your own dataset, first figure out what keys your environment passes to the policy server
        # and then modify the mappings below so your dataset's keys get matched to those target keys.
        # The repack transform simply remaps key names here.
        repack_transform = _transforms.Group(
            inputs=[
                _transforms.RepackTransform(
                    {
                        "observation/image": "image",
                        "observation/wrist_image": "wrist_image",
                        "observation/state": "state",
                        "actions": "actions",
                        "prompt": "prompt",
                    }
                )
            ]
        )

        # The data transforms are applied to the data coming from the dataset *and* during inference.
        # Below, we define the transforms for data going into the model (``inputs``) and the transforms
        # for data coming out of the model (``outputs``) (the latter is only used during inference).
        # We defined these transforms in `libero_policy.py`. You can check the detailed comments there for
        # how to modify the transforms to match your dataset. Once you created your own transforms, you can
        # replace the transforms below with your own.
        data_transforms = _transforms.Group(
            inputs=[libero_policy.LiberoInputs(action_dim=model_config.action_dim, model_type=model_config.model_type)],
            outputs=[libero_policy.LiberoOutputs()],
        )

        # One additional data transform: pi0 models are trained on delta actions (relative to the first
        # state in each action chunk). IF your data has ``absolute`` actions (e.g. target joint angles)
        # you can uncomment the following line to convert the actions to delta actions. The only exception
        # is for the gripper actions which are always absolute.
        # In the example below, we would apply the delta conversion to the first 6 actions (joints) and
        # leave the 7th action (gripper) unchanged, i.e. absolute.
        # In Libero, the raw actions in the dataset are already delta actions, so we *do not* need to
        # apply a separate delta conversion (that's why it's commented out). Choose whether to apply this
        # transform based on whether your dataset uses ``absolute`` or ``delta`` actions out of the box.

        # TODO(karl): comment this out once we have updated the Libero checkpoints to not use
        # the delta action transform
        delta_action_mask = _transforms.make_bool_mask(6, -1)
        data_transforms = data_transforms.push(
            inputs=[_transforms.DeltaActions(delta_action_mask)],
            outputs=[_transforms.AbsoluteActions(delta_action_mask)],
        )

        # Model transforms include things like tokenizing the prompt and action targets
        # You do not need to change anything here for your own dataset.
        model_transforms = ModelTransformFactory()(model_config)

        # We return all data transforms for training and inference. No need to change anything here.
        return dataclasses.replace(
            self.create_base_config(assets_dirs),
            repack_transforms=repack_transform,
            data_transforms=data_transforms,
            model_transforms=model_transforms,
        )



@dataclasses.dataclass(frozen=True)
class TrainConfig:
    # Name of the config. Must be unique. Will be used to reference this config.
    name: tyro.conf.Suppress[str]
    # Project name.
    project_name: str = "openpi"
    # Experiment name. Will be used to name the metadata and checkpoint directories.
    exp_name: str = tyro.MISSING

    # Defines the model config. Some attributes (action_dim, action_horizon, and max_token_len) are shared by all models
    # -- see BaseModelConfig. Specific model implementations (e.g., Pi0Config) inherit from BaseModelConfig and may
    # define additional attributes.
    model: _model.BaseModelConfig = dataclasses.field(default_factory=pi0.Pi0Config)

    # A weight loader can optionally load (possibly partial) weights from disk after the model is initialized.
    weight_loader: weight_loaders.WeightLoader = dataclasses.field(default_factory=weight_loaders.NoOpWeightLoader)

    lr_schedule: _optimizer.LRScheduleConfig = dataclasses.field(default_factory=_optimizer.CosineDecaySchedule)
    optimizer: _optimizer.OptimizerConfig = dataclasses.field(default_factory=_optimizer.AdamW)
    ema_decay: float | None = 0.99

    # Specifies which weights should be frozen.
    freeze_filter: tyro.conf.Suppress[Filter] = dataclasses.field(default_factory=nnx.Nothing)

    # Determines the data to be trained on.
    data: DataConfigFactory = dataclasses.field(default_factory=FakeDataConfig)

    # Base directory for config assets (e.g., norm stats).
    assets_base_dir: str = "./assets"
    # Base directory for checkpoints.
    checkpoint_base_dir: str = "./checkpoints"

    # Random seed that will be used by random generators during training.
    seed: int = 42
    # Global batch size.
    batch_size: int = 32
    # Number of workers to use for the data loader. Increasing this number will speed up data loading but
    # will increase memory and CPU usage.
    num_workers: int = 2
    # Number of train steps (batches) to run.
    num_train_steps: int = 30_000

    # How often (in steps) to log training metrics.
    log_interval: int = 100
    # How often (in steps) to save checkpoints.
    save_interval: int = 1000
    # If set, any existing checkpoints matching step % keep_period == 0 will not be deleted.
    keep_period: int | None = 5000

    # If true, will overwrite the checkpoint directory if it already exists.
    overwrite: bool = False
    # If true, will resume training from the last checkpoint.
    resume: bool = False

    # If true, will enable wandb logging.
    wandb_enabled: bool = True

    # Used to pass metadata to the policy server.
    policy_metadata: dict[str, Any] | None = None

    # If the value is greater than 1, FSDP will be enabled and shard across number of specified devices; overall
    # device memory will be reduced but training could potentially be slower.
    # eg. if total device is 4 and fsdp devices is 2; then the model will shard to 2 devices and run
    # data parallel between 2 groups of devices.
    fsdp_devices: int = 1

    @property
    def assets_dirs(self) -> pathlib.Path:
        """Get the assets directory for this config."""
        return (pathlib.Path(self.assets_base_dir) / self.name).resolve()

    @property
    def checkpoint_dir(self) -> pathlib.Path:
        """Get the checkpoint directory for this config."""
        if not self.exp_name:
            raise ValueError("--exp_name must be set")
        return (pathlib.Path(self.checkpoint_base_dir) / self.name / self.exp_name).resolve()

    @property
    def trainable_filter(self) -> nnx.filterlib.Filter:
        """Get the filter for the trainable parameters."""
        return nnx.All(nnx.Param, nnx.Not(self.freeze_filter))

    def __post_init__(self) -> None:
        if self.resume and self.overwrite:
            raise ValueError("Cannot resume and overwrite at the same time.")









@dataclasses.dataclass(frozen=True)
class LocalBridgeDataConfig(DataConfigFactory):
    """用于从本地Bridge数据集加载数据的配置类。"""
    # 数据集参数
    dataset_name: str = "bridge_dataset"
    data_dir: Optional[str] = "/home/jiaqi/tfds_datasets"
    split: str = "train"
    
    # 数据加载参数 - 基本参数
    batch_size: int = 32
    num_workers: int = 4
    shuffle_episodes: bool = True
    
    # 数据加载参数 - 内存优化参数
    shuffle_buffer_size: int = 100  # TF的shuffle缓冲区大小
    cache_size: int = 10  # LRU缓存大小
    prefetch_factor: int = 2  # 每个worker预取批次数
    pin_memory: bool = True  # 是否使用pin_memory加速传输
    
    # 模型相关参数
    default_prompt: Optional[str] = None
    use_delta_joint_actions: bool = True
    adapt_to_pi: bool = True
    
    # 其他参数
    kwargs: Dict[str, Any] = dataclasses.field(default_factory=dict)  # 额外参数
    
    # 数据转换
    repack_transforms: _transforms.Group = dataclasses.field(
        default_factory=lambda: _transforms.Group(
            inputs=[
                _transforms.RepackTransform(
                    {
                        "image": "observation.images.top",  # bridge使用"image"而不是"images"
                        "state": "observation.state",
                        "actions": "action",
                        "task": "prompt",  # 从task字段映射到prompt
                    }
                )
            ]
        )
    )

    @override
    def create(self, assets_dir: pathlib.Path, model_config: _model.BaseModelConfig) -> DataConfig:
        """创建数据配置。"""
        logger.info(f"创建本地Bridge数据集配置: {self.dataset_name}")
        
        # 配置数据转换
        is_franka = model_config.action_dim == 7
        logger.info(f"使用{'Franka (7-DOF)' if is_franka else '标准'} 机器人配置")
        
        # 转换操作（可以根据实际需要定制）
        data_transforms = self._create_transforms(model_config)
        
        # 应用增量动作转换
        if self.use_delta_joint_actions:
            if is_franka:  # Franka 7自由度
                delta_action_mask = _transforms.make_bool_mask(6, -1)  # 前6个是关节，最后一个是夹爪
            else:
                delta_action_mask = _transforms.make_bool_mask(6, -1, 6, -1)  # 默认掩码
                
            data_transforms = data_transforms.push(
                inputs=[_transforms.DeltaActions(delta_action_mask)],
                outputs=[_transforms.AbsoluteActions(delta_action_mask)],
            )
        
        # 模型特定转换
        model_transforms = ModelTransformFactory(default_prompt=self.default_prompt)(model_config)
        
        # 创建数据配置
        config = DataConfig(
            # 设置为None或使用本地路径标识符
            # repo_id=f"local://{self.dataset_name}_{self.split}",  # 使用更具体的ID
            repo_id=None,  # 使用更具体的ID
            asset_id="franka" if is_franka else "bridge",
            data_transforms=data_transforms,
            model_transforms=model_transforms,
            repack_transforms=self.repack_transforms,
        )

        # 记录数据集信息
        logger.info(f"本地数据集信息: 类型=local_bridge, 名称={self.dataset_name}, "
                    f"目录={self.data_dir}, 分割={self.split}")
        logger.info(f"数据加载参数: batch_size={self.batch_size}, workers={self.num_workers}, "
                   f"shuffle_buffer={self.shuffle_buffer_size}, cache_size={self.cache_size}")
    
        return config
    
    def _create_transforms(self, model_config: _model.BaseModelConfig) -> _transforms.Group:
        """不进行任何数据转换，直接返回空的Group。"""
        return _transforms.Group()
    
    def get_dataloader(self):
        """返回优化的Bridge数据加载器。
        
        此方法用于直接获取数据加载器，绕过OpenPI标准数据加载流程。
        """
        logger.info(f"创建内存优化的Bridge数据加载器: {self.dataset_name}, split={self.split}")
        
        # 合并kwargs和指定参数
        loader_kwargs = {
            "dataset_name": self.dataset_name,
            "split": self.split,
            "data_dir": self.data_dir,
            "batch_size": self.batch_size,
            "num_workers": self.num_workers,
            "shuffle_episodes": self.shuffle_episodes,
            "shuffle_buffer_size": self.shuffle_buffer_size,
            "prefetch_factor": self.prefetch_factor,
            "pin_memory": self.pin_memory,
            **self.kwargs  # 添加任何额外参数
        }
        
        return make_dataloader(**loader_kwargs)
    
    def get_dataset(self):
        """返回内存优化的数据集对象。"""
        logger.info(f"创建内存优化的Bridge数据集: {self.dataset_name}, "
                   f"shuffle_buffer={self.shuffle_buffer_size}, cache_size={self.cache_size}")
        
        # 合并kwargs和指定参数
        dataset_kwargs = {
            "dataset_name": self.dataset_name,
            "split": self.split,
            "data_dir": self.data_dir,
            "shuffle_episodes": self.shuffle_episodes,
            "shuffle_buffer_size": self.shuffle_buffer_size,
            "cache_size": self.cache_size,
            **{k: v for k, v in self.kwargs.items() if k not in ["prefetch_factor", "pin_memory"]}
        }
        
        return BridgeLeRobotIterableDataset(**dataset_kwargs)


# Use `get_config` if you need to get a config by name in your code.
_CONFIGS = [

    # 使用优化流式加载的本地数据集配置
    TrainConfig(
        name="pi0_franka_local",
        model=pi0_franka.Pi0FrankaConfig(),  # 使用专为Franka设计的模型配置
        data=LocalBridgeDataConfig(
            dataset_name="bridge_dataset",
            data_dir="/home/jiaqi/tfds_datasets",  # 数据目录
            split="train",
            default_prompt="manipulate objects with the robotic arm",
            use_delta_joint_actions=True,
            adapt_to_pi=True,
            # 流式加载优化参数
            batch_size=16,  # 降低批量大小减少内存使用
            num_workers=4,  # 并行加载工作进程数
            shuffle_episodes=True,
            shuffle_buffer_size=200,  # 控制TF shuffle缓冲区大小
            # 额外参数可通过kwargs传递
            kwargs={
                "cache_size": 5,  # 仅缓存5个最近的episodes
                "prefetch_factor": 2  # 每个worker预取批次数
            }
        ),
        # 从基础模型加载预训练权重
        weight_loader=weight_loaders.CheckpointWeightLoader("s3://openpi-assets/checkpoints/pi0_base/params"),
        # 训练参数
        num_train_steps=30_000,
        batch_size=16,  # 与数据加载器保持一致
    ),
    
    # 内存优化的LoRA微调版本
    TrainConfig(
        name="pi0_franka_local_lora",
        model=pi0_franka.Pi0FrankaConfig(
            paligemma_variant="gemma_2b_lora", 
            action_expert_variant="gemma_300m_lora"
        ),
        data=LocalBridgeDataConfig(
            dataset_name="bridge_dataset",  # 统一使用相同数据集名称
            data_dir="/home/jiaqi/tfds_datasets",  # 保持数据路径一致
            split="train",
            default_prompt="manipulate objects with the robotic arm",
            use_delta_joint_actions=True,
            # 流式加载优化参数
            batch_size=32,  # LoRA使用更小的模型，可以用更大批量
            num_workers=4,
            shuffle_episodes=True,
            shuffle_buffer_size=500,  # LoRA内存需求较小，可以用更大缓冲区
            kwargs={
                "cache_size": 10,
                "prefetch_factor": 2
            }
        ),
        weight_loader=weight_loaders.CheckpointWeightLoader("s3://openpi-assets/checkpoints/pi0_base/params"),
        num_train_steps=30_000,
        batch_size=32,  # 与数据加载器保持一致
        freeze_filter=pi0_franka.Pi0FrankaConfig(
            paligemma_variant="gemma_2b_lora", 
            action_expert_variant="gemma_300m_lora"
        ).get_freeze_filter(),
        ema_decay=None,
    )
    # ,

    # # 添加一个内存超级受限的配置
    # TrainConfig(
    #     name="pi0_franka_local_minimal",
    #     model=pi0_franka.Pi0FrankaConfig(
    #         paligemma_variant="gemma_2b_lora", 
    #         action_expert_variant="gemma_300m_lora"
    #     ),
    #     data=LocalBridgeDataConfig(
    #         dataset_name="bridge_dataset",
    #         data_dir="/home/jiaqi/tfds_datasets",
    #         split="train",
    #         default_prompt="manipulate objects with the robotic arm",
    #         use_delta_joint_actions=True,
    #         # 极限内存优化
    #         batch_size=8,  # 非常小的批量
    #         num_workers=2,  # 减少worker数量
    #         shuffle_episodes=True,
    #         shuffle_buffer_size=50,  # 最小的缓冲区
    #         kwargs={
    #             "cache_size": 2,  # 最小缓存
    #             "prefetch_factor": 1,  # 最小预取
    #             "pin_memory": False  # 关闭pin_memory可能在某些情况下减少内存使用
    #         }
    #     ),
    #     weight_loader=weight_loaders.CheckpointWeightLoader("s3://openpi-assets/checkpoints/pi0_base/params"),
    #     num_train_steps=30_000,
    #     batch_size=8,
    #     freeze_filter=pi0_franka.Pi0FrankaConfig(
    #         paligemma_variant="gemma_2b_lora", 
    #         action_expert_variant="gemma_300m_lora"
    #     ).get_freeze_filter(),
    #     ema_decay=None,
    #     # 为极限内存受限场景添加额外优化
    #     optimizer=_optimizer.AdamW(
    #         learning_rate=3e-5,
    #         weight_decay=0.01,
    #         b1=0.9,
    #         b2=0.999,
    #         eps=1e-8,
    #         # 添加梯度累积以使用更小批量同时保持更新步长
    #         gradient_accumulation_steps=4  # 等效于batch_size=32的更新大小
    #     )
    # )
]



if len({config.name for config in _CONFIGS}) != len(_CONFIGS):
    raise ValueError("Config names must be unique.")
_CONFIGS_DICT = {config.name: config for config in _CONFIGS}


def cli() -> TrainConfig:
    return tyro.extras.overridable_config_cli({k: (k, v) for k, v in _CONFIGS_DICT.items()})


def get_config(config_name: str) -> TrainConfig:
    """Get a config by name."""
    if config_name not in _CONFIGS_DICT:
        closest = difflib.get_close_matches(config_name, _CONFIGS_DICT.keys(), n=1, cutoff=0.0)
        closest_str = f" Did you mean '{closest[0]}'? " if closest else ""
        raise ValueError(f"Config '{config_name}' not found.{closest_str}")

    return _CONFIGS_DICT[config_name]

